#lang racket

;; Project 3: A church-compiler for Scheme, to Lambda-calculus

(provide church-compile
         ; provided conversions:
         church->nat
         church->bool
         church->listof)


;; Input language:
;
; e ::= (letrec ([x (lambda (x ...) e)]) e)    
;     | (let ([x e] ...) e)  
;     | (let* ([x e] ...) e)
;     | (lambda (x ...) e)
;     | (e e ...)    
;     | x  
;     | (and e ...) | (or e ...)
;     | (if e e e)
;     | (prim e) | (prim e e)
;     | datum
; datum ::= nat | (quote ()) | #t | #f 
; nat ::= 0 | 1 | 2 | ... 
; x is a symbol
; prim is a primitive operation in list prims
; The following are *extra credit*: -, =, sub1  
(define prims '(+ * - = add1 sub1 cons car cdr null? not zero?))

; This input language has semantics identical to Scheme / Racket, except:
;   + You will not be provided code that yields any kind of error in Racket
;   + You do not need to treat non-boolean values as #t at if, and, or forms
;   + primitive operations are either strictly unary (add1 sub1 null? zero? not car cdr), 
;                                           or binary (+ - * = cons)
;   + There will be no variadic functions or applications---but any fixed arity is allowed

;; Output language:

; e ::= (lambda (x) e)
;     | (e e)
;     | x
;
; also as interpreted by Racket


;; Using the following decoding functions:

; A church-encoded nat is a function taking an f, and x, returning (f^n x)
(define (church->nat c-nat)
  ((c-nat add1) 0))

; A church-encoded bool is a function taking a true-thunk and false-thunk,
;   returning (true-thunk) when true, and (false-thunk) when false
(define (church->bool c-bool)
  ((c-bool #t) #f))

; A church-encoded cons-cell is a function taking a when-cons callback, and a when-null callback (thunk),
;   returning when-cons applied on the car and cdr elements
; A church-encoded cons-cell is a function taking a when-cons callback, and a when-null callback (thunk),
;   returning the when-null thunk, applied on a dummy value (arbitrary value that will be thrown away)
(define ((church->listof T) c-lst)
  ; when it's a pair, convert the element with T, and the tail with (church->listof T)
  ((c-lst (lambda (a) (lambda (b) (cons (T a) ((church->listof T) b)))))
   ; when it's null, return Racket's null
   (lambda (_) '())))

; Define primitive operations and needed helpers using a top-level let form?
      

(define Y (lambda (f)
  ((lambda(x) (f (lambda (y) ((x x) y)))))
   (lambda(x) (f (lambda(y) ((x x) y))))))

;; Write your church-compiling code below:

; churchify recursively walks the AST and converts each expression in the input language (defined above)
;   to an equivalent (when converted back via each church->XYZ) expression in the output language (defined above)
(define (churchify e)
  (match e
    [`(let ([,xs ,rs] ...) ,body)
     (churchify `((lambda ,xs ,body) . ,rs))]
    
    ;[`(let* ([,(cons x e)] ...) ,body)
     ;(let recursive ([bind (reverse `((,x ,e) ...))])
      ; (if (null? bind)
       ;    body
        ;   (let* ([bindto (car bind)]
         ;         [rest (cdr bind)])
          ;   `((lambda ,(car bindto) ,(recursive rest))
           ;    ,(cdr bindto)))))]
    ;[`(letrec ([,xs ,rs] ...) ,body)
     ;`((Y (lambda (map car rc)
      ;      (lambda ,@(map car xs) ,body)))
       ;,@(map cdr rs))]
   

    [`(lambda (,x) ,e0)
     `(lambda(,x) ,(churchify e0))]
    
    [`(lambda (,x . ,rest) ,e0)
     `(lambda (,x) ,(churchify `(lambda ,rest ,e0)))]

    [(? symbol? x) x]

    [(? natural? nat)
     (define (wrap nat)
       (cond
         [(= 0 nat) 'x]
         
         [else `(f ,(wrap (- nat 1)))]))
     (churchify `(lambda (f) (lambda (x) ,(wrap nat))))]
    
    [`(,fun ,arg)
     `(,(churchify fun) ,(churchify arg))]
    [`(,fun ,arg . ,rest)
     (churchify `((,fun ,arg) . ,rest))]
    ))



; Takes a whole program in the input language, and converts it into an equivalent program in lambda-calc
(define (church-compile program)
  ; Define primitive operations and needed helpers using a top-level let form?

  (define myzero `(lambda(f)(lambda(x) x)))
  (define myone `(lambda(f)(lambda(x) (f x))))
  (define mytwo `(lambda(f)(lambda(x) f(f x))))
  (define mythree `(lambda(f)(lambda(x) f(f(f x)))))              
  (define myadd1 `(lambda(n)(lambda (f x) (f ((n f)) x))))
  (define myadd `(lambda (n0 n1) (lambda(f x)((n1 f) ((n0 f) x)))))
  (define mymultiply `(lambda(n m) (lambda (f) (n (m f)))))
  ;(define myzero? `(lambda (x) (= x 0) #t))
    

  (churchify
   `(let ([zero ,myzero]
          [one ,myone]
          [two ,mytwo]
          [three ,mythree]          
          [add1 ,myadd1]
          [+ ,myadd]
          [* ,mymultiply]
          [zero? ,myzero?])
      ,program)))

(require racket/trace)
(trace churchify)
